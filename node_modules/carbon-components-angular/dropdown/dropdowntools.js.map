{"version":3,"file":"dropdowntools.js","sourceRoot":"","sources":["../src/dropdown/dropdowntools.ts"],"names":[],"mappings":"AAAA,OAAO,EAAc,SAAS,EAAE,MAAM,MAAM,CAAC;AAC7C,OAAO,EAAE,YAAY,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,gBAAgB,CAAC;AAE3D;;;;;;;GAOG;AACH,MAAM,yBAAyB,MAAmB,EAAE,QAAQ;IAC3D,OAAO,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC;SACjC,IAAI,CACJ,YAAY,CAAC,GAAG,CAAC,EACjB,GAAG,CAAC,UAAC,EAAiB;QACrB,IAAI,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,UAAC,MAAM;YAC7B,OAAA,MAAM,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,CAAC;QAA1D,CAA0D,CAAC,CAAC;QAC7D,IAAI,EAAE,EAAE;YAAE,OAAO,EAAE,CAAC;SAAE;IACvB,CAAC,CAAC,EACF,MAAM,CAAC,UAAA,EAAE,IAAI,OAAA,CAAC,CAAC,EAAE,EAAJ,CAAI,CAAC,CAClB,CAAC;AACJ,CAAC;AAED,iEAAiE;AACjE,MAAM,CAAC,IAAM,SAAS,GAAG;IACxB,4FAA4F;IAC5F,IAAI,EAAE,UAAS,KAAK,EAAE,UAAU,EAAE,IAAS;QAAT,qBAAA,EAAA,SAAS;QAC1C,IAAI,KAAK,CAAC;QACV,KAAc,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK,EAAE;YAAhB,IAAI,CAAC,cAAA;YACT,IAAI,CAAC,KAAK,UAAU,EAAE;gBACrB,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACb,KAAK,GAAG,CAAC,CAAC;aACV;YACD,IAAI,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE;gBACtB,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACb,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC,KAAK,CAAC;gBACnD,IAAI,CAAC,KAAK,EAAE;oBAAE,IAAI,GAAG,EAAE,CAAC;iBAAE;aAC1B;SACD;QACD,OAAO,EAAC,KAAK,OAAA,EAAE,IAAI,MAAA,EAAC,CAAC;IACtB,CAAC;CACD,CAAC","sourcesContent":["import { Observable, fromEvent } from \"rxjs\";\nimport { debounceTime, map, filter } from \"rxjs/operators\";\n\n/**\n * returns an observable bound to keydown events that\n * filters to a single element where the first letter of\n * it's textContent matches the key pressed\n *\n * @param target element to watch\n * @param elements elements to search\n */\nexport function watchFocusJump(target: HTMLElement, elements): Observable<HTMLElement> {\n\treturn fromEvent(target, \"keydown\")\n\t\t.pipe(\n\t\t\tdebounceTime(150),\n\t\t\tmap((ev: KeyboardEvent) => {\n\t\t\t\tlet el = elements.find((itemEl) =>\n\t\t\t\t\titemEl.textContent.trim().toLowerCase().startsWith(ev.key));\n\t\t\t\tif (el) { return el; }\n\t\t\t}),\n\t\t\tfilter(el => !!el)\n\t\t);\n}\n\n/** bundle of functions to aid in manipulating tree structures */\nexport const treetools = {\n\t/** finds an item in a set of items and returns the item and path to the item as an array */\n\tfind: function(items, itemToFind, path = []) {\n\t\tlet found;\n\t\tfor (let i of items) {\n\t\t\tif (i === itemToFind) {\n\t\t\t\tpath.push(i);\n\t\t\t\tfound = i;\n\t\t\t}\n\t\t\tif (i.items && !found) {\n\t\t\t\tpath.push(i);\n\t\t\t\tfound = this.find(i.items, itemToFind, path).found;\n\t\t\t\tif (!found) { path = []; }\n\t\t\t}\n\t\t}\n\t\treturn {found, path};\n\t}\n};\n"]}