/**
 *
 * carbon-angular v0.0.0 | table-adapter.class.js
 *
 * Copyright 2014, 2020 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * An abstract class that represents a cell in a table
 */
var TableCellAdapter = /** @class */ (function () {
    function TableCellAdapter() {
    }
    return TableCellAdapter;
}());
export { TableCellAdapter };
/**
 * An abstract class that represents a row in a table
 */
var TableRowAdapter = /** @class */ (function () {
    function TableRowAdapter() {
    }
    return TableRowAdapter;
}());
export { TableRowAdapter };
/**
 * An abstract representation of a table that provides
 * a standard interface to query 2d tables for cell and row information.
 */
var TableAdapter = /** @class */ (function () {
    function TableAdapter() {
    }
    Object.defineProperty(TableAdapter.prototype, "lastColumnIndex", {
        /**
         * The last accessible column in the table
         */
        get: function () { return; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableAdapter.prototype, "lastRowIndex", {
        /**
         * The last accessible row in the table
         */
        get: function () { return; },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a cell from the table
     *
     * @param row index of the row
     * @param column index of the column
     */
    TableAdapter.prototype.getCell = function (row, column) { return; };
    /**
     * Returns a row from the table
     *
     * @param column index of the column
     */
    TableAdapter.prototype.getColumn = function (column) { return; };
    /**
     * Returns a row from the table
     *
     * @param row index of the row
     */
    TableAdapter.prototype.getRow = function (row) { return; };
    /**
     * Finds the column index of a given cell
     *
     * @param cell the cell to search for
     */
    TableAdapter.prototype.findColumnIndex = function (cell) { return; };
    /**
     * Finds the row index of a given cell
     *
     * @param cell the cell to search for
     */
    TableAdapter.prototype.findRowIndex = function (cell) { return; };
    /**
     * Finds the row and column index of a given cell
     *
     * @param cell the cell to search for
     * @returns a tuple that follows the `[row, column]` convention
     */
    TableAdapter.prototype.findIndex = function (cell) { return; };
    return TableAdapter;
}());
export { TableAdapter };
var TableDomSpanDirection;
(function (TableDomSpanDirection) {
    TableDomSpanDirection["colSpan"] = "colSpan";
    TableDomSpanDirection["rowSpan"] = "rowSpan";
})(TableDomSpanDirection || (TableDomSpanDirection = {}));
/**
 * A concrete implementation of `TableAdapter`
 *
 * Provides standard and consistent access to table cells and rows
 */
var TableDomAdapter = /** @class */ (function () {
    /**
     * `TableDomAdapter` works on a normal HTML table structure.
     * Custom tables that don't follow the standard structure should use a custom implementation of `TableAdapter`.
     *
     * The standard structure allows us to directly query rows for cells and indexes - though we do have to handle colspans specially.
     *
     * @param tableElement the root HTML table element.
     */
    function TableDomAdapter(tableElement) {
        this.tableElement = tableElement;
    }
    Object.defineProperty(TableDomAdapter.prototype, "lastColumnIndex", {
        /**
         * The last accessible column in the table
         */
        get: function () {
            return this.getRealRowLength(this.tableElement.rows[0]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableDomAdapter.prototype, "lastRowIndex", {
        /**
         * The last accessible row in the table
         */
        get: function () {
            return this.tableElement.rows.length - 1;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a cell from the table taking colspans in to account.
     *
     * @param row index of the row
     * @param column index of the column
     */
    TableDomAdapter.prototype.getCell = function (row, column) {
        var col = this.getColumn(column);
        return this.findCellInColumn(col, row).cell;
    };
    /**
     * Returns a column from the table, using the `id` and `headers` attributes
     *
     * See here for more detail these attributes: https://www.w3.org/TR/WCAG20-TECHS/H43.html
     *
     * @param column the index of the column
     */
    TableDomAdapter.prototype.getColumn = function (column) {
        var firstHeader = Array.from(this.tableElement.rows[0].cells);
        var _a = this.findCellInRow(firstHeader, column), header = _a.cell, realColumnIndex = _a.realIndex;
        var linkedCells = [];
        for (var i = 1; i < this.tableElement.rows.length; i++) {
            var row = this.tableElement.rows[i];
            // query for any cells that are linked to the given header id
            // `~=` matches values in space separated lists - so `[headers~='foo']` would match `headers="foo bar"` and `headers="foo"`
            // but not `headers="bar"` or `headers="bar baz"`
            var linkedRowCells = row.querySelectorAll("[headers~='" + header.id + "']");
            // if we have more than one cell, get the one that is closest to the column
            if (linkedRowCells.length > 1) {
                var cell = this.findCellInRow(Array.from(linkedRowCells), column - realColumnIndex).cell;
                linkedCells.push(cell);
            }
            else if (linkedRowCells[0]) {
                linkedCells.push(linkedRowCells[0]);
            }
        }
        // return an empty array if we can't find any linked cells
        // returning anything else would be a lie
        if (!linkedCells) {
            return [];
        }
        return [header].concat(linkedCells);
    };
    /**
     * Returns a row from the table
     *
     * @param row index of the row
     */
    TableDomAdapter.prototype.getRow = function (row) {
        return this.tableElement.rows[row];
    };
    /**
     * Finds the column index of a given cell
     *
     * @param cell the cell to search for
     */
    TableDomAdapter.prototype.findColumnIndex = function (cell) {
        var row = this.getRow(this.findRowIndex(cell));
        // if the cell has linked headers we can do a more accurate lookup
        if (cell.headers) {
            var ids_2 = cell.headers.split(" ");
            var headerRows = Array.from(this.tableElement.tHead.rows);
            var indexes = [];
            // start from the last row and work up
            for (var _i = 0, _a = headerRows.reverse(); _i < _a.length; _i++) {
                var headerRow = _a[_i];
                var headerCells = Array.from(headerRow.cells);
                var header = headerCells.find(function (headerCell) { return ids_2.includes(headerCell.id); });
                // if we have a matching header, find it's index (adjusting for colspans)
                if (header) {
                    // this is borrowed from below
                    var cellIndex_1 = 0;
                    for (var _b = 0, headerCells_1 = headerCells; _b < headerCells_1.length; _b++) {
                        var c = headerCells_1[_b];
                        if (c === header) {
                            break;
                        }
                        cellIndex_1 += c.colSpan;
                    }
                    indexes.push(cellIndex_1);
                }
            }
            // sort the indexes largest to smallest to find the closest matching header index
            var firstIndex = indexes.sort(function (a, b) { return b - a; })[0];
            // search the row for cells that share the header
            var similarCells = [];
            for (var _c = 0, ids_1 = ids_2; _c < ids_1.length; _c++) {
                var id = ids_1[_c];
                // there's no selector that will match two space separated lists,
                // so we have to iterate through the ids and query the row for each
                var rowCells = Array.from(row.querySelectorAll("[headers~='" + id + "']"));
                for (var _d = 0, rowCells_1 = rowCells; _d < rowCells_1.length; _d++) {
                    var rowCell = rowCells_1[_d];
                    // only keep one set of cells
                    if (!similarCells.includes(rowCell)) {
                        similarCells.push(rowCell);
                    }
                }
            }
            // DOM order is not preserved, so we have to sort the row
            similarCells = similarCells.sort(function (a, b) { return a.cellIndex - b.cellIndex; });
            // return the header index plus any adjustment within that headers column
            return firstIndex + similarCells.indexOf(cell);
        }
        // fallback if the cell isn't linked to any headers
        var cellIndex = 0;
        for (var _e = 0, _f = Array.from(row.cells); _e < _f.length; _e++) {
            var c = _f[_e];
            if (c === cell) {
                break;
            }
            cellIndex += c.colSpan;
        }
        return cellIndex;
    };
    /**
     * Finds the row index of a given cell
     *
     * @param cell the cell to search for
     */
    TableDomAdapter.prototype.findRowIndex = function (cell) {
        for (var _i = 0, _a = Array.from(this.tableElement.rows); _i < _a.length; _i++) {
            var row = _a[_i];
            if (row.contains(cell)) {
                return row.rowIndex;
            }
        }
    };
    /**
     * Finds the row and column index of a given cell
     *
     * @param cell the cell to search for
     * @returns a tuple that follows the `[row, column]` convention
     */
    TableDomAdapter.prototype.findIndex = function (cell) {
        return [this.findRowIndex(cell), this.findColumnIndex(cell)];
    };
    /**
     * Helper function that returns the "real" length of a row.
     * Only accurate with regard to colspans (though that's sufficient for it's uses here)
     *
     * TODO: Take rowSpan into account
     *
     * @param row the row to get the length of
     */
    TableDomAdapter.prototype.getRealRowLength = function (row) {
        // start at -1 since the colspans will sum to 1 index greater than the total
        return Array.from(row.cells).reduce(function (count, cell) { return count + cell.colSpan; }, -1);
    };
    /**
     * Finds a cell and it's real index given an array of cells, a target index, and the spanning direction
     *
     * @param cells An array of cells to search
     * @param targetIndex The index we think the cell is located at
     * @param spanDirection The direction of the cell spans. Should be `"colSpan"` for a row and `"rowSpan"` for a column
     */
    TableDomAdapter.prototype.findCell = function (cells, targetIndex, spanDirection) {
        // rows/cols can have fewer total cells than the actual table
        // the model pretends all rows/cols behave the same (with col/row spans > 1 being N cells long)
        // this maps that view to the HTML view (col/row spans > 1 are one element, so the array is shorter)
        var realIndex = 0;
        // i is only used for iterating the cells
        for (var i = 0; i < targetIndex;) {
            // skip the next N cells
            i += cells[realIndex][spanDirection];
            // don't bump realIndex if i now exceeds the cell we're shooting for
            if (i > targetIndex) {
                break;
            }
            // finally, increment realIndex (to keep it generally in step with i)
            realIndex++;
        }
        return {
            cell: cells[realIndex],
            realIndex: realIndex
        };
    };
    /**
     * Helper method around `findCell`, searches based on a row of cells
     *
     * @param row the row of elements to search
     * @param index the index of the element
     */
    TableDomAdapter.prototype.findCellInRow = function (row, index) {
        return this.findCell(row, index, TableDomSpanDirection.colSpan);
    };
    /**
     * Helper method around `findCell`, searches based on a column of cells
     *
     * @param col the column of elements to search
     * @param index the index of the element
     */
    TableDomAdapter.prototype.findCellInColumn = function (col, index) {
        return this.findCell(col, index, TableDomSpanDirection.rowSpan);
    };
    return TableDomAdapter;
}());
export { TableDomAdapter };
//# sourceMappingURL=table-adapter.class.js.map