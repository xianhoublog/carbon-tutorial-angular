{"version":3,"file":"table-adapter.class.js","sourceRoot":"","sources":["../src/table/table-adapter.class.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * An abstract class that represents a cell in a table\n */\nexport abstract class TableCellAdapter {\n\t/**\n\t * The index of the cell in the table\n\t */\n\tcellIndex: number;\n\t/**\n\t * The number of columns spanned by this cell\n\t */\n\tcolSpan: number;\n\t/**\n\t * The number of rows spanned by this cell\n\t */\n\trowSpan: number;\n}\n\n/**\n * An abstract class that represents a row in a table\n */\nexport abstract class TableRowAdapter {\n\t/**\n\t * The index of the row in the table\n\t */\n\trowIndex: number;\n\t/**\n\t * An array (or `HTMLCollection`) of `TableCellAdapter`s\n\t */\n\tcells: HTMLCollection | TableCellAdapter[];\n}\n\n/**\n * An abstract representation of a table that provides\n * a standard interface to query 2d tables for cell and row information.\n */\nexport abstract class TableAdapter {\n\t/**\n\t * The last accessible column in the table\n\t */\n\tpublic get lastColumnIndex(): number { return; }\n\n\t/**\n\t * The last accessible row in the table\n\t */\n\tpublic get lastRowIndex(): number { return; }\n\n\t/**\n\t * Returns a cell from the table\n\t *\n\t * @param row index of the row\n\t * @param column index of the column\n\t */\n\tgetCell(row: number, column: number): TableCellAdapter { return; }\n\n\t/**\n\t * Returns a row from the table\n\t *\n\t * @param column index of the column\n\t */\n\tgetColumn(column: number): TableCellAdapter[] { return; }\n\n\t/**\n\t * Returns a row from the table\n\t *\n\t * @param row index of the row\n\t */\n\tgetRow(row: number): TableRowAdapter { return; }\n\n\t/**\n\t * Finds the column index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t */\n\tfindColumnIndex(cell: TableCellAdapter): number { return; }\n\n\t/**\n\t * Finds the row index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t */\n\tfindRowIndex(cell: TableCellAdapter): number { return; }\n\n\t/**\n\t * Finds the row and column index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t * @returns a tuple that follows the `[row, column]` convention\n\t */\n\tfindIndex(cell: TableCellAdapter): [number, number] { return; }\n}\n\nenum TableDomSpanDirection {\n\tcolSpan = \"colSpan\",\n\trowSpan = \"rowSpan\"\n}\n\n/**\n * A concrete implementation of `TableAdapter`\n *\n * Provides standard and consistent access to table cells and rows\n */\nexport class TableDomAdapter implements TableAdapter {\n\t/**\n\t * The last accessible column in the table\n\t */\n\tpublic get lastColumnIndex() {\n\t\treturn this.getRealRowLength(this.tableElement.rows[0]);\n\t}\n\n\t/**\n\t * The last accessible row in the table\n\t */\n\tpublic get lastRowIndex() {\n\t\treturn this.tableElement.rows.length - 1;\n\t}\n\n\t/**\n\t * `TableDomAdapter` works on a normal HTML table structure.\n\t * Custom tables that don't follow the standard structure should use a custom implementation of `TableAdapter`.\n\t *\n\t * The standard structure allows us to directly query rows for cells and indexes - though we do have to handle colspans specially.\n\t *\n\t * @param tableElement the root HTML table element.\n\t */\n\tconstructor(public tableElement: HTMLTableElement) { }\n\n\t/**\n\t * Returns a cell from the table taking colspans in to account.\n\t *\n\t * @param row index of the row\n\t * @param column index of the column\n\t */\n\tgetCell(row: number, column: number): HTMLTableCellElement {\n\t\tconst col = this.getColumn(column);\n\n\t\treturn this.findCellInColumn(col, row).cell;\n\t}\n\n\t/**\n\t * Returns a column from the table, using the `id` and `headers` attributes\n\t *\n\t * See here for more detail these attributes: https://www.w3.org/TR/WCAG20-TECHS/H43.html\n\t *\n\t * @param column the index of the column\n\t */\n\tgetColumn(column: number): HTMLTableCellElement[] {\n\t\tconst firstHeader = Array.from(this.tableElement.rows[0].cells);\n\n\t\tconst { cell: header, realIndex: realColumnIndex } = this.findCellInRow(firstHeader, column);\n\n\t\tconst linkedCells: HTMLTableCellElement[] = [];\n\n\t\tfor (let i = 1; i < this.tableElement.rows.length; i++) {\n\t\t\tconst row = this.tableElement.rows[i];\n\t\t\t// query for any cells that are linked to the given header id\n\t\t\t// `~=` matches values in space separated lists - so `[headers~='foo']` would match `headers=\"foo bar\"` and `headers=\"foo\"`\n\t\t\t// but not `headers=\"bar\"` or `headers=\"bar baz\"`\n\t\t\tconst linkedRowCells: NodeListOf<HTMLTableCellElement> = row.querySelectorAll(`[headers~='${header.id}']`);\n\t\t\t// if we have more than one cell, get the one that is closest to the column\n\t\t\tif (linkedRowCells.length > 1) {\n\t\t\t\tconst { cell } = this.findCellInRow(Array.from(linkedRowCells), column - realColumnIndex);\n\t\t\t\tlinkedCells.push(cell);\n\t\t\t} else if (linkedRowCells[0]) {\n\t\t\t\tlinkedCells.push(linkedRowCells[0]);\n\t\t\t}\n\t\t}\n\n\t\t// return an empty array if we can't find any linked cells\n\t\t// returning anything else would be a lie\n\t\tif (!linkedCells) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn [header, ...linkedCells];\n\t}\n\n\t/**\n\t * Returns a row from the table\n\t *\n\t * @param row index of the row\n\t */\n\tgetRow(row: number): HTMLTableRowElement {\n\t\treturn this.tableElement.rows[row];\n\t}\n\n\t/**\n\t * Finds the column index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t */\n\tfindColumnIndex(cell: HTMLTableCellElement): number {\n\t\tconst row = this.getRow(this.findRowIndex(cell));\n\t\t// if the cell has linked headers we can do a more accurate lookup\n\t\tif (cell.headers) {\n\t\t\tconst ids = cell.headers.split(\" \");\n\t\t\tconst headerRows = Array.from(this.tableElement.tHead.rows);\n\t\t\tconst indexes = [];\n\n\t\t\t// start from the last row and work up\n\t\t\tfor (const headerRow of headerRows.reverse()) {\n\t\t\t\tconst headerCells = Array.from(headerRow.cells);\n\t\t\t\tconst header = headerCells.find(headerCell => ids.includes(headerCell.id));\n\t\t\t\t// if we have a matching header, find it's index (adjusting for colspans)\n\t\t\t\tif (header) {\n\t\t\t\t\t// this is borrowed from below\n\t\t\t\t\tlet cellIndex = 0;\n\t\t\t\t\tfor (const c of headerCells) {\n\t\t\t\t\t\tif (c === header) { break; }\n\t\t\t\t\t\tcellIndex += c.colSpan;\n\t\t\t\t\t}\n\t\t\t\t\tindexes.push(cellIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// sort the indexes largest to smallest to find the closest matching header index\n\t\t\tconst firstIndex = indexes.sort((a, b) => b - a)[0];\n\n\t\t\t// search the row for cells that share the header\n\t\t\tlet similarCells = [];\n\t\t\tfor (const id of ids) {\n\t\t\t\t// there's no selector that will match two space separated lists,\n\t\t\t\t// so we have to iterate through the ids and query the row for each\n\t\t\t\tconst rowCells = Array.from(row.querySelectorAll(`[headers~='${id}']`));\n\t\t\t\tfor (const rowCell of rowCells) {\n\t\t\t\t\t// only keep one set of cells\n\t\t\t\t\tif (!similarCells.includes(rowCell)) {\n\t\t\t\t\t\tsimilarCells.push(rowCell);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// DOM order is not preserved, so we have to sort the row\n\t\t\tsimilarCells = similarCells.sort((a: HTMLTableCellElement, b: HTMLTableCellElement) => a.cellIndex - b.cellIndex);\n\n\t\t\t// return the header index plus any adjustment within that headers column\n\t\t\treturn firstIndex + similarCells.indexOf(cell);\n\t\t}\n\n\t\t// fallback if the cell isn't linked to any headers\n\t\tlet cellIndex = 0;\n\t\tfor (const c of Array.from(row.cells)) {\n\t\t\tif (c === cell) { break; }\n\t\t\tcellIndex += c.colSpan;\n\t\t}\n\t\treturn cellIndex;\n\t}\n\n\t/**\n\t * Finds the row index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t */\n\tfindRowIndex(cell: HTMLTableCellElement): number {\n\t\tfor (const row of Array.from(this.tableElement.rows)) {\n\t\t\tif (row.contains(cell)) {\n\t\t\t\treturn row.rowIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Finds the row and column index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t * @returns a tuple that follows the `[row, column]` convention\n\t */\n\tfindIndex(cell: HTMLTableCellElement): [number, number] {\n\t\treturn [this.findRowIndex(cell), this.findColumnIndex(cell)];\n\t}\n\n\t/**\n\t * Helper function that returns the \"real\" length of a row.\n\t * Only accurate with regard to colspans (though that's sufficient for it's uses here)\n\t *\n\t * TODO: Take rowSpan into account\n\t *\n\t * @param row the row to get the length of\n\t */\n\tprotected getRealRowLength(row: HTMLTableRowElement): number {\n\t\t// start at -1 since the colspans will sum to 1 index greater than the total\n\t\treturn Array.from(row.cells).reduce((count, cell) => count + cell.colSpan, -1);\n\t}\n\n\t/**\n\t * Finds a cell and it's real index given an array of cells, a target index, and the spanning direction\n\t *\n\t * @param cells An array of cells to search\n\t * @param targetIndex The index we think the cell is located at\n\t * @param spanDirection The direction of the cell spans. Should be `\"colSpan\"` for a row and `\"rowSpan\"` for a column\n\t */\n\tprotected findCell(cells: HTMLTableCellElement[], targetIndex: number, spanDirection: TableDomSpanDirection) {\n\t\t// rows/cols can have fewer total cells than the actual table\n\t\t// the model pretends all rows/cols behave the same (with col/row spans > 1 being N cells long)\n\t\t// this maps that view to the HTML view (col/row spans > 1 are one element, so the array is shorter)\n\t\tlet realIndex = 0;\n\t\t// i is only used for iterating the cells\n\t\tfor (let i = 0; i < targetIndex;) {\n\t\t\t// skip the next N cells\n\t\t\ti += cells[realIndex][spanDirection];\n\t\t\t// don't bump realIndex if i now exceeds the cell we're shooting for\n\t\t\tif (i > targetIndex) { break; }\n\t\t\t// finally, increment realIndex (to keep it generally in step with i)\n\t\t\trealIndex++;\n\t\t}\n\n\t\treturn {\n\t\t\tcell: cells[realIndex],\n\t\t\trealIndex\n\t\t};\n\t}\n\n\t/**\n\t * Helper method around `findCell`, searches based on a row of cells\n\t *\n\t * @param row the row of elements to search\n\t * @param index the index of the element\n\t */\n\tprotected findCellInRow(row: HTMLTableCellElement[], index: number) {\n\t\treturn this.findCell(row, index, TableDomSpanDirection.colSpan);\n\t}\n\n\t/**\n\t * Helper method around `findCell`, searches based on a column of cells\n\t *\n\t * @param col the column of elements to search\n\t * @param index the index of the element\n\t */\n\tprotected findCellInColumn(col: HTMLTableCellElement[], index: number) {\n\t\treturn this.findCell(col, index, TableDomSpanDirection.rowSpan);\n\t}\n}\n"]}