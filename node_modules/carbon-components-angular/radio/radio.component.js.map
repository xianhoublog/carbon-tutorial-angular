{"version":3,"file":"radio.component.js","sourceRoot":"","sources":["../src/radio/radio.component.ts"],"names":[],"mappings":"AAAA,OAAO,EACN,SAAS,EACT,KAAK,EACL,WAAW,EACX,MAAM,EACN,YAAY,EACZ,MAAM,eAAe,CAAC;AACvB,OAAO,EAAE,iBAAiB,EAAE,MAAM,gBAAgB,CAAC;AACnD,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AAEnD;;;;;;;;;;;;GAYG;AACH;IAAA;QAyCU,YAAO,GAAG,KAAK,CAAC;QAEhB,SAAI,GAAG,EAAE,CAAC;QAEV,aAAQ,GAAG,KAAK,CAAC;QAEjB,mBAAc,GAAsB,OAAO,CAAC;QAYrD;;WAEG;QACM,aAAQ,GAAG,KAAK,CAAC;QAC1B;;WAEG;QACM,UAAK,GAAG,EAAE,CAAC;QACpB;;WAEG;QACM,aAAQ,GAAG,KAAK,CAAC;QAC1B;;WAEG;QACM,OAAE,GAAG,WAAS,KAAK,CAAC,UAAU,EAAI,CAAC;QAC5C;;WAEG;QACO,WAAM,GAAG,IAAI,YAAY,EAAe,CAAC;QACnD;;WAEG;QACuB,SAAI,GAAG,OAAO,CAAC;QAEM,cAAS,GAAG,IAAI,CAAC;QAMtD,gBAAW,GAAG,EAAE,CAAC;QAE3B;;WAEG;QACH,uBAAkB,GAAG,UAAC,KAAkB,IAAM,CAAC,CAAC;IAqBjD,CAAC;IAnEA,sBAAa,iCAAc;aAI3B;YACC,IAAI,IAAI,CAAC,WAAW,EAAE;gBACrB,OAAO,IAAI,CAAC,WAAW,CAAC;aACxB;YACD,OAAO,WAAS,IAAI,CAAC,EAAI,CAAC;QAC3B,CAAC;aATD,UAA4B,KAAa;YACxC,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;QAC1B,CAAC;;;OAAA;IAmCD,sBAA+D,4BAAS;aAAxE;YACC,OAAO,IAAI,CAAC,cAAc,KAAK,MAAM,CAAC;QACvC,CAAC;;;OAAA;IASD;;;OAGG;IACH,wBAAQ,GAAR,UAAS,KAAY;QACpB,KAAK,CAAC,eAAe,EAAE,CAAC;QACxB,IAAI,CAAC,OAAO,GAAI,KAAK,CAAC,MAA2B,CAAC,OAAO,CAAC;QAC1D,IAAM,UAAU,GAAG,IAAI,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACrD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC7B,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;IACrC,CAAC;IAED;;;OAGG;IACH,0CAA0B,GAA1B,UAA2B,EAAgC;QAC1D,IAAI,CAAC,kBAAkB,GAAG,EAAE,CAAC;IAC9B,CAAC;IA/ED;;OAEG;IACI,gBAAU,GAAG,CAAC,CAAC;;gBAvCtB,SAAS,SAAC;oBACV,QAAQ,EAAE,WAAW;oBACrB,QAAQ,EAAE,wrBAwBT;oBACD,SAAS,EAAE;wBACV;4BACC,OAAO,EAAE,iBAAiB;4BAC1B,WAAW,EAAE,KAAK;4BAClB,KAAK,EAAE,IAAI;yBACX;qBACD;iBACD;;;0BAOC,KAAK;uBAEL,KAAK;2BAEL,KAAK;iCAEL,KAAK;iCAEL,KAAK;2BAaL,KAAK;wBAIL,KAAK;2BAIL,KAAK;qBAIL,KAAK;yBAIL,MAAM;uBAIN,WAAW,SAAC,WAAW;4BAEvB,WAAW,SAAC,gCAAgC;4BAE5C,WAAW,SAAC,4CAA4C;;IA8B1D,YAAC;CAAA,AApHD,IAoHC;SAjFY,KAAK","sourcesContent":["import {\n\tComponent,\n\tInput,\n\tHostBinding,\n\tOutput,\n\tEventEmitter\n} from \"@angular/core\";\nimport { NG_VALUE_ACCESSOR } from \"@angular/forms\";\nimport { RadioChange } from \"./radio-change.class\";\n\n/**\n * class: Radio (extends Checkbox)\n *\n * selector: `n-radio`\n *\n * source: `src/forms/radio.component.ts`\n *\n * ```html\n * <ibm-radio [(ngModel)]=\"radioState\">Radio</ibm-radio>\n * ```\n *\n * Also see: [`RadioGroup`](#ibm-radio-group)\n */\n@Component({\n\tselector: \"ibm-radio\",\n\ttemplate: `\n\t\t<input\n\t\t\t*ngIf=\"!skeleton\"\n\t\t\tclass=\"bx--radio-button\"\n\t\t\ttype=\"radio\"\n\t\t\t[checked]=\"checked\"\n\t\t\t[disabled]=\"disabled\"\n\t\t\t[name]=\"name\"\n\t\t\t[id]=\"id\"\n\t\t\t[required]=\"required\"\n\t\t\t[value]=\"value\"\n\t\t\t[attr.aria-labelledby]=\"ariaLabelledby\"\n\t\t\t(change)=\"onChange($event)\">\n\t\t<div *ngIf=\"skeleton\" class=\"bx--radio-button bx--skeleton\"></div>\n\t\t<label\n\t\t\tclass=\"bx--radio-button__label\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--skeleton': skeleton\n\t\t\t}\"\n\t\t\t[for]=\"id\"\n\t\t\tid=\"label-{{id}}\">\n\t\t\t<span class=\"bx--radio-button__appearance\"></span>\n\t\t\t<ng-content></ng-content>\n\t\t</label>\n\t`,\n\tproviders: [\n\t\t{\n\t\t\tprovide: NG_VALUE_ACCESSOR,\n\t\t\tuseExisting: Radio,\n\t\t\tmulti: true\n\t\t}\n\t]\n})\nexport class Radio {\n\t/**\n\t * Used to dynamically create unique ids for the `Radio`.\n\t */\n\tstatic radioCount = 0;\n\n\t@Input() checked = false;\n\n\t@Input() name = \"\";\n\n\t@Input() disabled = false;\n\n\t@Input() labelPlacement: \"right\" | \"left\" =  \"right\";\n\n\t@Input() set ariaLabelledby(value: string) {\n\t\tthis._labelledby = value;\n\t}\n\n\tget ariaLabelledby() {\n\t\tif (this._labelledby) {\n\t\t\treturn this._labelledby;\n\t\t}\n\t\treturn `label-${this.id}`;\n\t}\n\t/**\n\t * Sets the HTML required attribute\n\t */\n\t@Input() required = false;\n\t/**\n\t * The value of the `Radio`.\n\t */\n\t@Input() value = \"\";\n\t/**\n\t * Set to `true` for a loading table.\n\t */\n\t@Input() skeleton = false;\n\t/**\n\t * The id for the `Radio`.\n\t */\n\t@Input() id = `radio-${Radio.radioCount++}`;\n\t/**\n\t * emits when the state of the radio changes\n\t */\n\t@Output() change = new EventEmitter<RadioChange>();\n\t/**\n\t * Binds 'radio' value to the role attribute for `Radio`.\n\t */\n\t@HostBinding(\"attr.role\") role = \"radio\";\n\n\t@HostBinding(\"class.bx--radio-button-wrapper\") hostClass = true;\n\n\t@HostBinding(\"class.bx--radio-button-wrapper--label-left\") get labelLeft() {\n\t\treturn this.labelPlacement === \"left\";\n\t}\n\n\tprotected _labelledby = \"\";\n\n\t/**\n\t * Handler provided by the `RadioGroup` to bubble events up\n\t */\n\tradioChangeHandler = (event: RadioChange) => {};\n\n\t/**\n\t * Synchronizes with the `RadioGroup` in the event of a changed `Radio`.\n\t * Emits the changes of both the `RadioGroup` and `Radio`.\n\t */\n\tonChange(event: Event) {\n\t\tevent.stopPropagation();\n\t\tthis.checked = (event.target as HTMLInputElement).checked;\n\t\tconst radioEvent = new RadioChange(this, this.value);\n\t\tthis.change.emit(radioEvent);\n\t\tthis.radioChangeHandler(radioEvent);\n\t}\n\n\t/**\n\t * Method called by `RadioGroup` with a callback function to bubble `RadioChange` events\n\t * @param fn callback that expects a `RadioChange` as an argument\n\t */\n\tregisterRadioChangeHandler(fn: (event: RadioChange) => void) {\n\t\tthis.radioChangeHandler = fn;\n\t}\n}\n"]}